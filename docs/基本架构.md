# 基本架构说明（草案）

## 1. 整体架构概览

- 前端：Flutter（多端应用）
- 后端：FastAPI（REST API）
- 数据库：MariaDB（主业务数据，使用 SQLAlchemy / async SQLAlchemy）
- 缓存 / 会话 / 队列：Redis（替代“jedis”概念）
- 智能体：LangGraph（后期接入，独立子模块 / 服务）
- 接口风格：REST / 后期可逐步演进为部分 GraphQL（可选，`strawberry` / `ariadne` 等）

---

## 2. 前端（Flutter）

- 与后端通过 HTTP/HTTPS + JSON 通信
- 使用 token（JWT）做登录态管理
- 只做 UI + 简单业务逻辑，复杂规则尽量放到后端

---

## 3. 后端（FastAPI）

- 使用 FastAPI 提供 REST API
- 运行环境：
    - Uvicorn / Hypercorn 作为 ASGI 服务器
    - 生产环境推荐：Nginx + Uvicorn 多进程部署

- 业务模块划分（按 Python 包 / 路由模块拆分）：
    - 用户与权限模块
    - 业务核心模块（与你的领域相关）
    - 智能体接口模块（与 LangGraph 通信）

- 技术选型建议：
    - Web 框架：`fastapi`
    - 数据访问：
        - ORM：`SQLAlchemy`（可选 async 版本）
        - 连接 MariaDB：`asyncmy` / `mysqlclient` / `pymysql` 等
    - 序列化 / 校验：Pydantic（FastAPI 内置）
    - 身份认证：OAuth2 + JWT
    - CORS：FastAPI 的 `CORSMiddleware`（Flutter 调试用）
    - 配置管理：`python-dotenv` 或 Pydantic Settings

- 配置层面：
    - 数据源：MariaDB（集中建表 / 迁移可以用 Alembic）
    - 缓存：Redis（登录态缓存、验证码、限流、队列）
    - 日志：标准库 logging + 统一 JSON 格式输出

---

## 4. 数据层

- 主库：MariaDB
    - 存用户、业务数据、操作日志等
    - 表结构通过 SQLAlchemy 的模型定义，迁移用 Alembic

- 缓存 / 会话 / 队列：Redis
    - 登录态（可选）/ 黑名单 token
    - 短信 / 邮件验证码
    - 接口限流计数
    - 任务队列（可配合 RQ / Celery）

---

## 5. 智能体（LangGraph）

- 作为独立服务或独立 FastAPI 子应用（router）：
    - FastAPI 提供 HTTP API 给前端
    - FastAPI 再去调用 LangGraph（HTTP / gRPC / 内部 SDK 均可）

- 建议：
    - LangGraph 相关逻辑与通用业务逻辑解耦，单独一个 Python 包 / 模块
    - I/O 统一使用 JSON，便于前后端、模型三方联调
    - 对接大模型 Key、路由策略、上下文管理等集中在一层封装

---

## 6. 登录与权限框架（推荐方案）

目标：简单、稳定、适合 Flutter 调用，充分利用 FastAPI 的依赖注入机制。

### 6.1 基础认证

1. 用户模型与存储

     - 使用自定义 `User` 表（SQLAlchemy 模型），字段：
         - id / username / email / hashed_password / is_active / is_superuser 等
     - 密码加密：`passlib[bcrypt]` 等方案

2. FastAPI 认证基础

     - 使用 OAuth2 Password Flow + JWT：
         - 依赖：`python-jose` / `PyJWT` 生成与验证 JWT
         - 登录接口：
             - 使用 `OAuth2PasswordRequestForm` 接收用户名与密码
             - 校验后签发 `access_token` + `refresh_token`（可选）
         - Flutter 在请求头携带：
             - `Authorization: Bearer <access_token>`

3. Token 认证流程建议

     - `access_token`：
         - 有效期较短（例如 15–60 分钟）
     - `refresh_token`：
         - 有效期较长（例如 7–30 天）
     - 刷新策略：
         - 提供刷新接口，验证 `refresh_token`，重新发放 `access_token`
         - 可选：将注销 / 黑名单 token 存 Redis

4. 与 FastAPI 集成

     - 利用 FastAPI 的依赖注入定义：
         - `get_current_user`：从 JWT 中解析 user_id，查询数据库返回 User
         - `get_current_active_user`：在上层再校验 `is_active`
     - 所有需要登录的接口依赖 `get_current_active_user`

### 6.2 权限控制

先从简单开始，以后再细化。

1. 角色和权限模型

     - 表结构（示例）：
         - `Role`：角色（管理员 / 普通用户 / …）
         - `Permission`：权限点（如 `user:create`, `order:read`）
         - 关联表：`role_permissions`，`user_roles`
     - 用户 → 属于若干角色
     - 角色 → 包含若干权限

2. 接口级权限控制

     - 定义权限依赖：
         - `require_permissions("user:read", "user:update")`
     - 在路由上使用：
         - `@router.get("/users", dependencies=[Depends(require_permissions("user:read"))])`
     - `require_permissions` 内部：
         - 从 `get_current_user` 注入当前用户
         - 合并角色权限，判断是否包含指定权限码

3. 对象级权限（可后期引入）

     - 如果需要“只看自己创建的数据”等细粒度控制：
         - 在具体接口里，基于 `current_user.id` + 业务字段过滤
         - 或封装统一的权限检查函数（代替 Django 的 `django-guardian`）

### 6.3 第三方登录（可选）

如有微信 / 钉钉 / 企业微信 / Google 等第三方登录需求：

- 后端（FastAPI）：
    - 通过 OAuth2 / OpenID Connect 协议与第三方对接
    - 可选依赖：`Authlib`（推荐处理 OAuth2）、对应平台 SDK
    - 流程：
        1. 前端跳转到第三方授权页或拉起第三方 App
        2. 授权完成后拿到 `code` / `access_token`
        3. FastAPI 接口接收 `code`，向第三方换取用户信息
        4. 通过唯一标识（如 openid / unionid / sub）在本地绑定账号
        5. 为本地用户签发 JWT，走统一登录流程

- 前端（Flutter）：
    - 使用各平台 Flutter SDK 完成授权
    - 将 `code` 或第三方 token 传给后端绑定 / 登录接口

---

## 7. 其他建议（可以后面再做）

- 日志与监控：
    - FastAPI 使用 Python `logging` 统一输出
    - 日志收集到 ELK / Loki / Promtail 等（后期）
    - 可引入 APM（如 OpenTelemetry + Jaeger）做调用链追踪

- 配置管理：
    - 本地 `.env` + Pydantic Settings（集中管理 DB / Redis / JWT Secret 等）
    - 生产环境通过环境变量注入

- 定时任务与异步任务：
    - 简单定时：Linux `crontab` + 调用 FastAPI 内部逻辑的脚本
    - 复杂任务 / 队列：
        - 使用 Celery + Redis / RabbitMQ
        - 或者使用 RQ / Dramatiq / APScheduler 等

> 总结：  
> 登录与权限推荐组合：**FastAPI + OAuth2 Password Flow + JWT + 自定义角色 / 权限表**。  
> 先保证“能用、简单”，再根据实际业务扩展细粒度权限、单点登录与第三方登录。 基本架构说明（草案）

## 1. 整体架构概览

- 前端：Flutter（多端应用）
- 后端：Django（REST API）
- 数据库：MariaDB（主业务数据）
- 缓存 / 会话 / 队列：Redis（建议，用于替代“jedis”概念，jedis 是 Java 客户端）
- 智能体：LangGraph（后期接入，独立子模块）
- 接口风格：REST / 后期可逐步演进为部分 GraphQL（可选）

---

## 2. 前端（Flutter）

- 与后端通过 HTTP/HTTPS + JSON 通信
- 使用 token（JWT）做登录态管理
- 只做 UI + 简单业务逻辑，复杂规则尽量放到后端

---

## 3. 后端（Django）

- 使用 Django + Django REST framework（DRF）提供 REST API
- 业务模块划分：
    - 用户与权限模块
    - 业务核心模块（与你的领域相关）
    - 智能体接口模块（与 LangGraph 通信）
- 配置层面：
    - 数据源：MariaDB
    - 缓存：Redis
    - 跨域：`django-cors-headers`（给 Flutter 调试用）

---

## 4. 数据层

- 主库：MariaDB
    - 存用户、业务数据、操作日志等
- 缓存 / 会话 / 队列：Redis
    - 登录态（可选）、验证码、限流、任务队列等

---

## 5. 智能体（LangGraph）

- 作为独立服务或独立 Django app：
    - Django 提供接口给前端
    - Django 再去调用 LangGraph（HTTP / gRPC / 内部 SDK 均可）
- 输入输出统一使用 JSON，便于前后端、模型三方联调

---

## 6. 登录与权限框架（推荐方案）

目标：简单、稳定、适合 Flutter 调用。

### 6.1 基础认证

1. 使用 Django 自带用户体系 `django.contrib.auth`
     - 用户模型：可用内置 `User`，后期需要可再扩展
     - 支持密码加密、权限组、超级管理员等

2. API 层使用 DRF：
     - 包：`djangorestframework`
     - 负责：序列化、视图集、统一返回格式

3. Token 认证使用 JWT：
     - 包：`djangorestframework-simplejwt`
     - 方案：
         - 登录成功后返回 `access` + `refresh` token
         - Flutter 在请求头携带 `Authorization: Bearer <access_token>`
         - 过期后用 `refresh_token` 换新 token

### 6.2 权限控制

先从简单开始，以后再细化。

1. 使用 Django 内置权限 + 角色（组）：
     - 用户 → 属于若干组（角色）
     - 组 → 对应一批权限（增删改查等）
     - DRF 中使用权限类（`IsAuthenticated`, 自定义权限类）做接口保护

2. 如后期需要“按对象粒度”的权限（比如某用户只看自己创建的对象）：
     - 可引入：`django-guardian` 实现对象级权限（先不引入，等需求明确再上）

### 6.3 第三方登录（可选）

如有微信/钉钉/企业微信/Google 等第三方登录需求：

- 后端：
    - 使用 `django-allauth` + `dj-rest-auth`（或类似方案）做统一账号体系
- 前端：
    - Flutter 做第三方 SDK 授权，拿到 code/token 后调你后端接口绑定账号

---

## 7. 其他建议（可以后面再做）

- 日志与监控：
    - 使用 Django 日志 + 收集到 ELK / Loki（后期）
- 配置管理：
    - 本地 `.env` + 生产环境环境变量
- 定时任务：
    - 简单用 `crontab` + Django 管理命令
    - 复杂时引入 Celery + Redis

> 总结：  
> 登录与权限推荐组合：**Django Auth + DRF + SimpleJWT + 内置权限/角色**。  
> 先保证“能用、简单”，后续根据实际业务再做精细化权限与单点登录扩展。